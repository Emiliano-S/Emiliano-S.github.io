{"version":3,"sources":["node_modules/firebase/app/dist/esm/index.esm.js","node_modules/@angular/fire/fesm2022/angular-fire.mjs","node_modules/firebase/compat/app/dist/esm/index.esm.js","node_modules/@angular/fire/fesm2022/angular-fire-compat.mjs","node_modules/@firebase/app-check/dist/esm/index.esm2017.js","node_modules/@angular/fire/fesm2022/angular-fire-app-check.mjs","node_modules/@angular/fire/fesm2022/angular-fire-compat-auth.mjs"],"sourcesContent":["import { registerVersion } from '@firebase/app';\nexport * from '@firebase/app';\nvar name = \"firebase\";\nvar version = \"10.12.2\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nregisterVersion(name, version, 'app');\n","import * as i0 from '@angular/core';\nimport { Version, Injectable } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { tap, observeOn, subscribeOn } from 'rxjs/operators';\nconst VERSION = /*#__PURE__*/new Version('ANGULARFIRE2_VERSION');\nconst ɵisSupportedError = module => `The APP_INITIALIZER that is \"making\" isSupported() sync for the sake of convenient DI has not resolved in this\ncontext. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling\n\\`await isSupported()\\`, then retrieve the instance from the injector manually \\`injector.get(${module})\\`.`;\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp);\n    // Was provide* only called once, using the default app? If so use that\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  }\n  // Grab the default instance from the defaultApp\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate({\n    optional: true\n  });\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\nclass ɵAppCheckInstances {\n  constructor() {\n    return ɵgetAllInstancesOf(ɵAPP_CHECK_PROVIDER_NAME);\n  }\n}\nconst ɵAPP_CHECK_PROVIDER_NAME = 'app-check';\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n  zone;\n  delegate;\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  now() {\n    return this.delegate.now();\n  }\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (state) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    };\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\nclass BlockUntilFirstOperator {\n  zone;\n  // @ts-ignore\n  task = null;\n  constructor(zone) {\n    this.zone = zone;\n  }\n  call(subscriber, source) {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    // @ts-ignore\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap({\n      next: unscheduleTask,\n      complete: unscheduleTask,\n      error: unscheduleTask\n    })).subscribe(subscriber).add(unscheduleTask);\n  }\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n}\nlet ɵAngularFireSchedulers = /*#__PURE__*/(() => {\n  class ɵAngularFireSchedulers {\n    ngZone;\n    outsideAngular;\n    insideAngular;\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      // @ts-ignore\n      this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n      // @ts-ignore\n      this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n      globalThis.ɵAngularFireScheduler ||= this;\n    }\n    static ɵfac = function ɵAngularFireSchedulers_Factory(t) {\n      return new (t || ɵAngularFireSchedulers)(i0.ɵɵinject(i0.NgZone));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ɵAngularFireSchedulers,\n      factory: ɵAngularFireSchedulers.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ɵAngularFireSchedulers;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getSchedulers() {\n  const schedulers = globalThis.ɵAngularFireScheduler;\n  if (!schedulers) {\n    throw new Error(`Either AngularFireModule has not been provided in your AppModule (this can be done manually or implictly using\nprovideFirebaseApp) or you're calling an AngularFire method outside of an NgModule (which is not supported).`);\n  }\n  return schedulers;\n}\nfunction runOutsideAngular(fn) {\n  return getSchedulers().ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n  return getSchedulers().ngZone.run(() => fn());\n}\nfunction observeOutsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().outsideAngular));\n}\nfunction observeInsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().insideAngular));\n}\nfunction keepUnstableUntilFirst(obs$) {\n  return ɵkeepUnstableUntilFirstFactory(getSchedulers())(obs$);\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return function keepUnstableUntilFirst(obs$) {\n    obs$ = obs$.lift(new BlockUntilFirstOperator(schedulers.ngZone));\n    return obs$.pipe(\n    // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n    subscribeOn(schedulers.outsideAngular),\n    // Run operators inside the angular zone (e.g. side effects via tap())\n    observeOn(schedulers.insideAngular)\n    // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n    // share()\n    );\n  };\n}\n// @ts-ignore\nconst zoneWrapFn = (it, macrotask) => {\n  // eslint-disable-next-line @typescript-eslint/no-this-alias\n  const _this = this;\n  // function() is needed for the arguments object\n  return function () {\n    const _arguments = arguments;\n    if (macrotask) {\n      setTimeout(() => {\n        if (macrotask.state === 'scheduled') {\n          macrotask.invoke();\n        }\n      }, 10);\n    }\n    return run(() => it.apply(_this, _arguments));\n  };\n};\nconst ɵzoneWrap = (it, blockUntilFirst) => {\n  // function() is needed for the arguments object\n  return function () {\n    // @ts-ignore\n    let macrotask;\n    const _arguments = arguments;\n    // if this is a callback function, e.g, onSnapshot, we should create a microtask and invoke it\n    // only once one of the callback functions is tripped.\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof _arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          // @ts-ignore\n          macrotask ||= run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n        }\n        // TODO create a microtask to track callback functions\n        _arguments[i] = zoneWrapFn(_arguments[i], macrotask);\n      }\n    }\n    const ret = runOutsideAngular(() => it.apply(this, _arguments));\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        const schedulers = getSchedulers();\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n    if (ret instanceof Observable) {\n      return ret.pipe(keepUnstableUntilFirst);\n    } else if (ret instanceof Promise) {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      return run(() => new Promise((resolve, reject) => ret.then(it => run(() => resolve(it)), reason => run(() => reject(reason)))));\n    } else if (typeof ret === 'function' && macrotask) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      return function () {\n        setTimeout(() => {\n          if (macrotask && macrotask.state === 'scheduled') {\n            macrotask.invoke();\n          }\n        }, 10);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { VERSION, keepUnstableUntilFirst, observeInsideAngular, observeOutsideAngular, ɵAPP_CHECK_PROVIDER_NAME, ɵAngularFireSchedulers, ɵAppCheckInstances, ɵZoneScheduler, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵisSupportedError, ɵkeepUnstableUntilFirstFactory, ɵzoneWrap };\n","import firebase from '@firebase/app-compat';\nexport { default } from '@firebase/app-compat';\nvar name = \"firebase\";\nvar version = \"10.12.2\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfirebase.registerVersion(name, version, 'app-compat');\n","import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, NgZone, Optional, VERSION as VERSION$1, PLATFORM_ID, NgModule, Inject } from '@angular/core';\nimport { VERSION } from '@angular/fire';\nimport firebase from 'firebase/compat/app';\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nconst ɵlazySDKProxy = (klass, observable, zone, options = {}) => {\n  return new Proxy(klass, {\n    get: (_, name) => zone.runOutsideAngular(() => {\n      if (klass[name]) {\n        if (options?.spy?.get) {\n          options.spy.get(name, klass[name]);\n        }\n        return klass[name];\n      }\n      if (noopFunctions.indexOf(name) > -1) {\n        return () => undefined;\n      }\n      const promise = observable.toPromise().then(mod => {\n        const ret = mod?.[name];\n        // TODO move to proper type guards\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret?.then) {\n          return ret.then(res => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => undefined, {\n        get: (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can\n        apply: (self, _, args) => promise.then(it => {\n          const res = it?.(...args);\n          if (options?.spy?.apply) {\n            options.spy.apply(name, args, res);\n          }\n          return res;\n        })\n      });\n    })\n  });\n};\nconst ɵapplyMixins = (derivedCtor, constructors) => {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\nclass FirebaseApp {\n  constructor(app) {\n    return app;\n  }\n}\nconst FIREBASE_OPTIONS = /*#__PURE__*/new InjectionToken('angularfire2.app.options');\nconst FIREBASE_APP_NAME = /*#__PURE__*/new InjectionToken('angularfire2.app.name');\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name;\n  // Added any due to some inconsistency between @firebase/app and firebase types\n  const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0];\n  // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n  const app = existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config));\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      const hmr = !!module.hot;\n      log$1('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n    }\n  } catch (e) {/* empty */}\n  return new FirebaseApp(app);\n}\nconst log$1 = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    // eslint-disable-next-line no-console\n    console[level](...args);\n  }\n};\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [/*#__PURE__*/new Optional(), FIREBASE_APP_NAME]]\n};\nlet AngularFireModule = /*#__PURE__*/(() => {\n  class AngularFireModule {\n    static initializeApp(options, nameOrConfig) {\n      return {\n        ngModule: AngularFireModule,\n        providers: [{\n          provide: FIREBASE_OPTIONS,\n          useValue: options\n        }, {\n          provide: FIREBASE_APP_NAME,\n          useValue: nameOrConfig\n        }]\n      };\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructor(platformId) {\n      firebase.registerVersion('angularfire', VERSION.full, 'core');\n      firebase.registerVersion('angularfire', VERSION.full, 'app-compat');\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      firebase.registerVersion('angular', VERSION$1.full, platformId.toString());\n    }\n    static ɵfac = function AngularFireModule_Factory(t) {\n      return new (t || AngularFireModule)(i0.ɵɵinject(PLATFORM_ID));\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AngularFireModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [FIREBASE_APP_PROVIDER]\n    });\n  }\n  return AngularFireModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n  const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find(it => it[0] === cacheKey) || [];\n  if (instance) {\n    if (!matchDep(deps, cachedDeps)) {\n      log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      log('warn', {\n        is: deps,\n        was: cachedDeps\n      });\n    }\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n    return newInstance;\n  }\n}\nfunction matchDep(a, b) {\n  try {\n    return a.toString() === b.toString();\n  } catch (_) {\n    return a === b;\n  }\n}\nconst IS_HMR = typeof module !== 'undefined' && !!module.hot;\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    // eslint-disable-next-line no-console\n    console[level](...args);\n  }\n};\nglobalThis.ɵAngularfireInstanceCache ||= [];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, ɵapplyMixins, ɵcacheInstance, ɵfirebaseAppFactory, ɵlazySDKProxy };\n","import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, uuidv4, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n  activated: false,\n  tokenObservers: []\n};\nconst DEBUG_STATE = {\n  initialized: false,\n  enabled: false\n};\n/**\r\n * Gets a reference to the state object.\r\n */\nfunction getStateReference(app) {\n  return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\n}\n/**\r\n * Set once on initialization. The map should hold the same reference to the\r\n * same object until this entry is deleted.\r\n */\nfunction setInitialState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n  return APP_CHECK_STATES.get(app);\n}\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n  /**\r\n   * The offset time before token natural expiration to run the refresh.\r\n   * This is currently 5 minutes.\r\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\r\n   * This is the first retrial wait after an error. This is currently\r\n   * 30 seconds.\r\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\r\n   * This is the maximum retrial wait, currently 16 minutes.\r\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\r\n * One day in millis, for certain error code backoffs.\r\n */\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nclass Refresher {\n  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n  start() {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n  stop() {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n  isRunning() {\n    return !!this.pending;\n  }\n  async process(hasSucceeded) {\n    this.stop();\n    try {\n      this.pending = new Deferred();\n      this.pending.promise.catch(_e => {\n        /* ignore */\n      });\n      await sleep(this.getNextRun(hasSucceeded));\n      // Why do we resolve a promise, then immediate wait for it?\n      // We do it to make the promise chain cancellable.\n      // We can call stop() which rejects the promise before the following line execute, which makes\n      // the code jump to the catch block.\n      // TODO: unit test this\n      this.pending.resolve();\n      await this.pending.promise;\n      this.pending = new Deferred();\n      this.pending.promise.catch(_e => {\n        /* ignore */\n      });\n      await this.operation();\n      this.pending.resolve();\n      await this.pending.promise;\n      this.process(true).catch(() => {\n        /* we don't care about the result */\n      });\n    } catch (error) {\n      if (this.retryPolicy(error)) {\n        this.process(false).catch(() => {\n          /* we don't care about the result */\n        });\n      } else {\n        this.stop();\n      }\n    }\n  }\n  getNextRun(hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  }\n}\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst ERRORS = {\n  [\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' + 'different options. To avoid this error, call initializeAppCheck() with the ' + 'same options as when it was originally called. This will return the ' + 'already initialized instance.',\n  [\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' + 'Call initializeAppCheck() before instantiating other Firebase services.',\n  [\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.',\n  [\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [\"storage-open\" /* AppCheckError.STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [\"storage-get\" /* AppCheckError.STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [\"storage-set\" /* AppCheckError.STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */]: 'ReCAPTCHA error.',\n  [\"throttled\" /* AppCheckError.THROTTLED */]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction getRecaptcha(isEnterprise = false) {\n  var _a;\n  if (isEnterprise) {\n    return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n  }\n  return self.grecaptcha;\n}\nfunction ensureActivated(app) {\n  if (!getStateReference(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */, {\n      appName: app.name\n    });\n  }\n}\nfunction getDurationString(durationInMillis) {\n  const totalSeconds = Math.round(durationInMillis / 1000);\n  const days = Math.floor(totalSeconds / (3600 * 24));\n  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n  const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\n  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n  let result = '';\n  if (days) {\n    result += pad(days) + 'd:';\n  }\n  if (hours) {\n    result += pad(hours) + 'h:';\n  }\n  result += pad(minutes) + 'm:' + pad(seconds) + 's';\n  return result;\n}\nfunction pad(value) {\n  if (value === 0) {\n    return '00';\n  }\n  return value >= 10 ? value.toString() : '0' + value;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nasync function exchangeToken({\n  url,\n  body\n}, heartbeatServiceProvider) {\n  const headers = {\n    'Content-Type': 'application/json'\n  };\n  // If heartbeat service exists, add heartbeat header string to the header.\n  const heartbeatService = heartbeatServiceProvider.getImmediate({\n    optional: true\n  });\n  if (heartbeatService) {\n    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n    if (heartbeatsHeader) {\n      headers['X-Firebase-Client'] = heartbeatsHeader;\n    }\n  }\n  const options = {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers\n  };\n  let response;\n  try {\n    response = await fetch(url, options);\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */, {\n      originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n    });\n  }\n  if (response.status !== 200) {\n    throw ERROR_FACTORY.create(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */, {\n      httpStatus: response.status\n    });\n  }\n  let responseBody;\n  try {\n    // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n    responseBody = await response.json();\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n      originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n    });\n  }\n  // Protobuf duration format.\n  // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n  const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n  if (!match || !match[2] || isNaN(Number(match[1]))) {\n    throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n      originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` + `format: ${responseBody.ttl}`\n    });\n  }\n  const timeToLiveAsNumber = Number(match[1]) * 1000;\n  const now = Date.now();\n  return {\n    token: responseBody.token,\n    expireTimeMillis: now + timeToLiveAsNumber,\n    issuedAtTimeMillis: now\n  };\n}\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_v3_token': reCAPTCHAToken\n    }\n  };\n}\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_enterprise_token': reCAPTCHAToken\n    }\n  };\n}\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        var _a;\n        reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\nasync function write(key, value) {\n  const db = await getDBPromise();\n  const transaction = db.transaction(STORE_NAME, 'readwrite');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.put({\n    compositeKey: key,\n    value\n  });\n  return new Promise((resolve, reject) => {\n    request.onsuccess = _event => {\n      resolve();\n    };\n    transaction.onerror = event => {\n      var _a;\n      reject(ERROR_FACTORY.create(\"storage-set\" /* AppCheckError.STORAGE_WRITE */, {\n        originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n      }));\n    };\n  });\n}\nasync function read(key) {\n  const db = await getDBPromise();\n  const transaction = db.transaction(STORE_NAME, 'readonly');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.get(key);\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      const result = event.target.result;\n      if (result) {\n        resolve(result.value);\n      } else {\n        resolve(undefined);\n      }\n    };\n    transaction.onerror = event => {\n      var _a;\n      reject(ERROR_FACTORY.create(\"storage-get\" /* AppCheckError.STORAGE_GET */, {\n        originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n      }));\n    };\n  });\n}\nfunction computeKey(app) {\n  return `${app.options.appId}-${app.name}`;\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst logger = new Logger('@firebase/app-check');\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\nasync function readTokenFromStorage(app) {\n  if (isIndexedDBAvailable()) {\n    let token = undefined;\n    try {\n      token = await readTokenFromIndexedDB(app);\n    } catch (e) {\n      // swallow the error and return undefined\n      logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n    }\n    return token;\n  }\n  return undefined;\n}\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\nfunction writeTokenToStorage(app, token) {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n    });\n  }\n  return Promise.resolve();\n}\nasync function readOrCreateDebugTokenFromStorage() {\n  /**\r\n   * Theoretically race condition can happen if we read, then write in 2 separate transactions.\r\n   * But it won't happen here, because this function will be called exactly once.\r\n   */\n  let existingDebugToken = undefined;\n  try {\n    existingDebugToken = await readDebugTokenFromIndexedDB();\n  } catch (_e) {\n    // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n  }\n  if (!existingDebugToken) {\n    // create a new debug token\n    const newToken = uuidv4();\n    // We don't need to block on writing to indexeddb\n    // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n    // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n    // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n    // You should switch to a different browser that supports indexeddb\n    writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n    return newToken;\n  } else {\n    return existingDebugToken;\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction isDebugMode() {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\nasync function getDebugToken() {\n  const state = getDebugState();\n  if (state.enabled && state.token) {\n    return state.token.promise;\n  } else {\n    // should not happen!\n    throw Error(`\n            Can't get debug token in production mode.\n        `);\n  }\n}\nfunction initializeDebugMode() {\n  const globals = getGlobal();\n  const debugState = getDebugState();\n  // Set to true if this function has been called, whether or not\n  // it enabled debug mode.\n  debugState.initialized = true;\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n  debugState.enabled = true;\n  const deferredToken = new Deferred();\n  debugState.token = deferredToken;\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nconst defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\nfunction formatDummyToken(tokenErrorData) {\n  return base64.encodeString(JSON.stringify(tokenErrorData), /* webSafe= */false);\n}\n/**\r\n * This function always resolves.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\nasync function getToken$2(appCheck, forceRefresh = false) {\n  const app = appCheck.app;\n  ensureActivated(app);\n  const state = getStateReference(app);\n  /**\r\n   * First check if there is a token in memory from a previous `getToken()` call.\r\n   */\n  let token = state.token;\n  let error = undefined;\n  /**\r\n   * If an invalid token was found in memory, clear token from\r\n   * memory and unset the local variable `token`.\r\n   */\n  if (token && !isValid(token)) {\n    state.token = undefined;\n    token = undefined;\n  }\n  /**\r\n   * If there is no valid token in memory, try to load token from indexedDB.\r\n   */\n  if (!token) {\n    // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n    const cachedToken = await state.cachedTokenPromise;\n    if (cachedToken) {\n      if (isValid(cachedToken)) {\n        token = cachedToken;\n      } else {\n        // If there was an invalid token in the indexedDB cache, clear it.\n        await writeTokenToStorage(app, undefined);\n      }\n    }\n  }\n  // Return the cached token (from either memory or indexedDB) if it's valid\n  if (!forceRefresh && token && isValid(token)) {\n    return {\n      token: token.token\n    };\n  }\n  // Only set to true if this `getToken()` call is making the actual\n  // REST call to the exchange endpoint, versus waiting for an already\n  // in-flight call (see debug and regular exchange endpoint paths below)\n  let shouldCallListeners = false;\n  /**\r\n   * DEBUG MODE\r\n   * If debug mode is set, and there is no cached token, fetch a new App\r\n   * Check token using the debug token, and return it directly.\r\n   */\n  if (isDebugMode()) {\n    // Avoid making another call to the exchange endpoint if one is in flight.\n    if (!state.exchangeTokenPromise) {\n      state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\n        // Clear promise when settled - either resolved or rejected.\n        state.exchangeTokenPromise = undefined;\n      });\n      shouldCallListeners = true;\n    }\n    const tokenFromDebugExchange = await state.exchangeTokenPromise;\n    // Write debug token to indexedDB.\n    await writeTokenToStorage(app, tokenFromDebugExchange);\n    // Write debug token to state.\n    state.token = tokenFromDebugExchange;\n    return {\n      token: tokenFromDebugExchange.token\n    };\n  }\n  /**\r\n   * There are no valid tokens in memory or indexedDB and we are not in\r\n   * debug mode.\r\n   * Request a new token from the exchange endpoint.\r\n   */\n  try {\n    // Avoid making another call to the exchange endpoint if one is in flight.\n    if (!state.exchangeTokenPromise) {\n      // state.provider is populated in initializeAppCheck()\n      // ensureActivated() at the top of this function checks that\n      // initializeAppCheck() has been called.\n      state.exchangeTokenPromise = state.provider.getToken().finally(() => {\n        // Clear promise when settled - either resolved or rejected.\n        state.exchangeTokenPromise = undefined;\n      });\n      shouldCallListeners = true;\n    }\n    token = await getStateReference(app).exchangeTokenPromise;\n  } catch (e) {\n    if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}`) {\n      // Warn if throttled, but do not treat it as an error.\n      logger.warn(e.message);\n    } else {\n      // `getToken()` should never throw, but logging error text to console will aid debugging.\n      logger.error(e);\n    }\n    // Always save error to be added to dummy token.\n    error = e;\n  }\n  let interopTokenResult;\n  if (!token) {\n    // If token is undefined, there must be an error.\n    // Return a dummy token along with the error.\n    interopTokenResult = makeDummyTokenResult(error);\n  } else if (error) {\n    if (isValid(token)) {\n      // It's also possible a valid token exists, but there's also an error.\n      // (Such as if the token is almost expired, tries to refresh, and\n      // the exchange request fails.)\n      // We add a special error property here so that the refresher will\n      // count this as a failed attempt and use the backoff instead of\n      // retrying repeatedly with no delay, but any 3P listeners will not\n      // be hindered in getting the still-valid token.\n      interopTokenResult = {\n        token: token.token,\n        internalError: error\n      };\n    } else {\n      // No invalid tokens should make it to this step. Memory and cached tokens\n      // are checked. Other tokens are from fresh exchanges. But just in case.\n      interopTokenResult = makeDummyTokenResult(error);\n    }\n  } else {\n    interopTokenResult = {\n      token: token.token\n    };\n    // write the new token to the memory state as well as the persistent storage.\n    // Only do it if we got a valid new token\n    state.token = token;\n    await writeTokenToStorage(app, token);\n  }\n  if (shouldCallListeners) {\n    notifyTokenListeners(app, interopTokenResult);\n  }\n  return interopTokenResult;\n}\n/**\r\n * Internal API for limited use tokens. Skips all FAC state and simply calls\r\n * the underlying provider.\r\n */\nasync function getLimitedUseToken$1(appCheck) {\n  const app = appCheck.app;\n  ensureActivated(app);\n  const {\n    provider\n  } = getStateReference(app);\n  if (isDebugMode()) {\n    const debugToken = await getDebugToken();\n    const {\n      token\n    } = await exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\n    return {\n      token\n    };\n  } else {\n    // provider is definitely valid since we ensure AppCheck was activated\n    const {\n      token\n    } = await provider.getToken();\n    return {\n      token\n    };\n  }\n}\nfunction addTokenListener(appCheck, type, listener, onError) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app);\n  const tokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  state.tokenObservers = [...state.tokenObservers, tokenObserver];\n  // Invoke the listener async immediately if there is a valid token\n  // in memory.\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve().then(() => {\n      listener({\n        token: validToken.token\n      });\n      initTokenRefresher(appCheck);\n    }).catch(() => {\n      /* we don't care about exceptions thrown in listeners */\n    });\n  }\n  /**\r\n   * Wait for any cached token promise to resolve before starting the token\r\n   * refresher. The refresher checks to see if there is an existing token\r\n   * in state and calls the exchange endpoint if not. We should first let the\r\n   * IndexedDB check have a chance to populate state if it can.\r\n   *\r\n   * Listener call isn't needed here because cachedTokenPromise will call any\r\n   * listeners that exist when it resolves.\r\n   */\n  // state.cachedTokenPromise is always populated in `activate()`.\n  void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\n}\nfunction removeTokenListener(app, listener) {\n  const state = getStateReference(app);\n  const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n  state.tokenObservers = newObservers;\n}\n/**\r\n * Logic to create and start refresher as needed.\r\n */\nfunction initTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app);\n  // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n  let refresher = state.tokenRefresher;\n  if (!refresher) {\n    refresher = createTokenRefresher(appCheck);\n    state.tokenRefresher = refresher;\n  }\n  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n    refresher.start();\n  }\n}\nfunction createTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  return new Refresher(\n  // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  async () => {\n    const state = getStateReference(app);\n    // If there is no token, we will try to load it from storage and use it\n    // If there is a token, we force refresh it because we know it's going to expire soon\n    let result;\n    if (!state.token) {\n      result = await getToken$2(appCheck);\n    } else {\n      result = await getToken$2(appCheck, true);\n    }\n    /**\r\n     * getToken() always resolves. In case the result has an error field defined, it means\r\n     * the operation failed, and we should retry.\r\n     */\n    if (result.error) {\n      throw result.error;\n    }\n    /**\r\n     * A special `internalError` field reflects that there was an error\r\n     * getting a new token from the exchange endpoint, but there's still a\r\n     * previous token that's valid for now and this should be passed to 2P/3P\r\n     * requests for a token. But we want this callback (`this.operation` in\r\n     * `Refresher`) to throw in order to kick off the Refresher's retry\r\n     * backoff. (Setting `hasSucceeded` to false.)\r\n     */\n    if (result.internalError) {\n      throw result.internalError;\n    }\n  }, () => {\n    return true;\n  }, () => {\n    const state = getStateReference(app);\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000;\n      // Do not allow refresh time to be past (expireTime - 5 minutes)\n      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\nfunction notifyTokenListeners(app, token) {\n  const observers = getStateReference(app).tokenObservers;\n  for (const observer of observers) {\n    try {\n      if (observer.type === \"EXTERNAL\" /* ListenerType.EXTERNAL */ && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (e) {\n      // Errors in the listener function itself are always ignored.\n    }\n  }\n}\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * AppCheck Service class.\r\n */\nclass AppCheckService {\n  constructor(app, heartbeatServiceProvider) {\n    this.app = app;\n    this.heartbeatServiceProvider = heartbeatServiceProvider;\n  }\n  _delete() {\n    const {\n      tokenObservers\n    } = getStateReference(this.app);\n    for (const tokenObserver of tokenObservers) {\n      removeTokenListener(this.app, tokenObserver.next);\n    }\n    return Promise.resolve();\n  }\n}\nfunction factory(app, heartbeatServiceProvider) {\n  return new AppCheckService(app, heartbeatServiceProvider);\n}\nfunction internalFactory(appCheck) {\n  return {\n    getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n    getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\n    addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, listener),\n    removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n  };\n}\nconst name = \"@firebase/app-check\";\nconst version = \"0.8.4\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\nfunction initializeV3(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(false);\n  if (!grecaptcha) {\n    loadReCAPTCHAV3Script(() => {\n      const grecaptcha = getRecaptcha(false);\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\nfunction initializeEnterprise(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(true);\n  if (!grecaptcha) {\n    loadReCAPTCHAEnterpriseScript(() => {\n      const grecaptcha = getRecaptcha(true);\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\n/**\r\n * Add listener to render the widget and resolve the promise when\r\n * the grecaptcha.ready() event fires.\r\n */\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n  grecaptcha.ready(() => {\n    // Invisible widgets allow us to set a different siteKey for each widget,\n    // so we use them to support multiple apps\n    renderInvisibleWidget(app, siteKey, grecaptcha, container);\n    initialized.resolve(grecaptcha);\n  });\n}\n/**\r\n * Add invisible div to page.\r\n */\nfunction makeDiv(app) {\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  return divId;\n}\nasync function getToken$1(app) {\n  ensureActivated(app);\n  // ensureActivated() guarantees that reCAPTCHAState is set\n  const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n  const recaptcha = await reCAPTCHAState.initialized.promise;\n  return new Promise((resolve, _reject) => {\n    // Updated after initialization is complete.\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n    recaptcha.ready(() => {\n      resolve(\n      // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n      recaptcha.execute(reCAPTCHAState.widgetId, {\n        action: 'fire_app_check'\n      }));\n    });\n  });\n}\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible',\n    // Success callback - set state\n    callback: () => {\n      getStateReference(app).reCAPTCHAState.succeeded = true;\n    },\n    // Failure callback - set state\n    'error-callback': () => {\n      getStateReference(app).reCAPTCHAState.succeeded = false;\n    }\n  });\n  const state = getStateReference(app);\n  state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), {\n    // state.reCAPTCHAState is set in the initialize()\n    widgetId\n  });\n}\nfunction loadReCAPTCHAV3Script(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_ENTERPRISE_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\nclass ReCaptchaV3Provider {\n  /**\r\n   * Create a ReCaptchaV3Provider instance.\r\n   * @param siteKey - ReCAPTCHA V3 siteKey.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\r\n     * Throttle requests on certain error codes to prevent too many retries\r\n     * in a short time.\r\n     */\n    this._throttleData = null;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n  async getToken() {\n    var _a, _b, _c;\n    throwIfThrottled(this._throttleData);\n    // Top-level `getToken()` has already checked that App Check is initialized\n    // and therefore this._app and this._heartbeatServiceProvider are available.\n    const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n      // reCaptcha.execute() throws null which is not very descriptive.\n      throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n    });\n    // Check if a failure state was set by the recaptcha \"error-callback\".\n    if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n      throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n    }\n    let result;\n    try {\n      result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n    } catch (e) {\n      if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n        this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n        throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n          httpStatus: this._throttleData.httpStatus\n        });\n      } else {\n        throw e;\n      }\n    }\n    // If successful, clear throttle data.\n    this._throttleData = null;\n    return result;\n  }\n  /**\r\n   * @internal\r\n   */\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeV3(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaV3Provider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n/**\r\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\nclass ReCaptchaEnterpriseProvider {\n  /**\r\n   * Create a ReCaptchaEnterpriseProvider instance.\r\n   * @param siteKey - reCAPTCHA Enterprise score-based site key.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\r\n     * Throttle requests on certain error codes to prevent too many retries\r\n     * in a short time.\r\n     */\n    this._throttleData = null;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n  async getToken() {\n    var _a, _b, _c;\n    throwIfThrottled(this._throttleData);\n    // Top-level `getToken()` has already checked that App Check is initialized\n    // and therefore this._app and this._heartbeatServiceProvider are available.\n    const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n      // reCaptcha.execute() throws null which is not very descriptive.\n      throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n    });\n    // Check if a failure state was set by the recaptcha \"error-callback\".\n    if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n      throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n    }\n    let result;\n    try {\n      result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n    } catch (e) {\n      if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n        this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n        throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n          time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n          httpStatus: this._throttleData.httpStatus\n        });\n      } else {\n        throw e;\n      }\n    }\n    // If successful, clear throttle data.\n    this._throttleData = null;\n    return result;\n  }\n  /**\r\n   * @internal\r\n   */\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeEnterprise(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n/**\r\n * Custom provider class.\r\n * @public\r\n */\nclass CustomProvider {\n  constructor(_customProviderOptions) {\n    this._customProviderOptions = _customProviderOptions;\n  }\n  /**\r\n   * @internal\r\n   */\n  async getToken() {\n    // custom provider\n    const customToken = await this._customProviderOptions.getToken();\n    // Try to extract IAT from custom token, in case this token is not\n    // being newly issued. JWT timestamps are in seconds since epoch.\n    const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n    // Very basic validation, use current timestamp as IAT if JWT\n    // has no `iat` field or value is out of bounds.\n    const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n    return Object.assign(Object.assign({}, customToken), {\n      issuedAtTimeMillis\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n  initialize(app) {\n    this._app = app;\n  }\n  /**\r\n   * @internal\r\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof CustomProvider) {\n      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();\n    } else {\n      return false;\n    }\n  }\n}\n/**\r\n * Set throttle data to block requests until after a certain time\r\n * depending on the failed request's status code.\r\n * @param httpStatus - Status code of failed request.\r\n * @param throttleData - `ThrottleData` object containing previous throttle\r\n * data state.\r\n * @returns Data about current throttle state and expiration time.\r\n */\nfunction setBackoff(httpStatus, throttleData) {\n  /**\r\n   * Block retries for 1 day for the following error codes:\r\n   *\r\n   * 404: Likely malformed URL.\r\n   *\r\n   * 403:\r\n   * - Attestation failed\r\n   * - Wrong API key\r\n   * - Project deleted\r\n   */\n  if (httpStatus === 404 || httpStatus === 403) {\n    return {\n      backoffCount: 1,\n      allowRequestsAfter: Date.now() + ONE_DAY,\n      httpStatus\n    };\n  } else {\n    /**\r\n     * For all other error codes, the time when it is ok to retry again\r\n     * is based on exponential backoff.\r\n     */\n    const backoffCount = throttleData ? throttleData.backoffCount : 0;\n    const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n    return {\n      backoffCount: backoffCount + 1,\n      allowRequestsAfter: Date.now() + backoffMillis,\n      httpStatus\n    };\n  }\n}\nfunction throwIfThrottled(throttleData) {\n  if (throttleData) {\n    if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n      // If before, throw.\n      throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n        httpStatus: throttleData.httpStatus\n      });\n    }\n  }\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Activate App Check for the given app. Can be called only once per app.\r\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\r\n * @param options - App Check initialization options\r\n * @public\r\n */\nfunction initializeAppCheck(app = getApp(), options) {\n  app = getModularInstance(app);\n  const provider = _getProvider(app, 'app-check');\n  // Ensure initializeDebugMode() is only called once.\n  if (!getDebugState().initialized) {\n    initializeDebugMode();\n  }\n  // Log a message containing the debug token when `initializeAppCheck()`\n  // is called in debug mode.\n  if (isDebugMode()) {\n    // Do not block initialization to get the token for the message.\n    void getDebugToken().then(token =>\n    // Not using logger because I don't think we ever want this accidentally hidden.\n    console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n  }\n  if (provider.isInitialized()) {\n    const existingInstance = provider.getImmediate();\n    const initialOptions = provider.getOptions();\n    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */, {\n        appName: app.name\n      });\n    }\n  }\n  const appCheck = provider.initialize({\n    options\n  });\n  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n  // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n  // exchange endpoint without an explicit call from the user either directly\n  // or through another Firebase library (storage, functions, etc.)\n  if (getStateReference(app).isTokenAutoRefreshEnabled) {\n    // Adding a listener will start the refresher and fetch a token if needed.\n    // This gets a token ready and prevents a delay when an internal library\n    // requests the token.\n    // Listener function does not need to do anything, its base functionality\n    // of calling getToken() already fetches token and writes it to memory/storage.\n    addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, () => {});\n  }\n  return appCheck;\n}\n/**\r\n * Activate App Check\r\n * @param app - Firebase app to activate App Check for.\r\n * @param provider - reCAPTCHA v3 provider or\r\n * custom token provider.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. If undefined, defaults to the\r\n * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n * false and can be set in the app config.\r\n */\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\n  // Create an entry in the APP_CHECK_STATES map. Further changes should\n  // directly mutate this object.\n  const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\n  state.activated = true;\n  state.provider = provider; // Read cached token from storage if it exists and store it in memory.\n  state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n    if (cachedToken && isValid(cachedToken)) {\n      state.token = cachedToken;\n      // notify all listeners with the cached token\n      notifyTokenListeners(app, {\n        token: cachedToken.token\n      });\n    }\n    return cachedToken;\n  });\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  state.provider.initialize(app);\n}\n/**\r\n * Set whether App Check will automatically refresh tokens as needed.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. This overrides any value set\r\n * during `initializeAppCheck()`.\r\n * @public\r\n */\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n  const app = appCheckInstance.app;\n  const state = getStateReference(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\n}\n/**\r\n * Get the current App Check token. Attaches to the most recent\r\n * in-flight request if one is present. Returns null if no token\r\n * is present and no token requests are in-flight.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n * If false, will use a cached token if found in storage.\r\n * @public\r\n */\nasync function getToken(appCheckInstance, forceRefresh) {\n  const result = await getToken$2(appCheckInstance, forceRefresh);\n  if (result.error) {\n    throw result.error;\n  }\n  return {\n    token: result.token\n  };\n}\n/**\r\n * Requests a Firebase App Check token. This method should be used\r\n * only if you need to authorize requests to a non-Firebase backend.\r\n *\r\n * Returns limited-use tokens that are intended for use with your\r\n * non-Firebase backend endpoints that are protected with\r\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\r\n * Replay Protection</a>. This method\r\n * does not affect the token generation behavior of the\r\n * #getAppCheckToken() method.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @returns The limited use token.\r\n * @public\r\n */\nfunction getLimitedUseToken(appCheckInstance) {\n  return getLimitedUseToken$1(appCheckInstance);\n}\n/**\r\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\r\n * pattern for public use.\r\n */\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError,\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n  let nextFn = () => {};\n  let errorFn = () => {};\n  if (onNextOrObserver.next != null) {\n    nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver;\n  }\n  if (onNextOrObserver.error != null) {\n    errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n  addTokenListener(appCheckInstance, \"EXTERNAL\" /* ListenerType.EXTERNAL */, nextFn, errorFn);\n  return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n\n/**\r\n * The Firebase App Check Web SDK.\r\n *\r\n * @remarks\r\n * Firebase App Check does not work in a Node.js environment using `ReCaptchaV3Provider` or\r\n * `ReCaptchaEnterpriseProvider`, but can be used in Node.js if you use\r\n * `CustomProvider` and write your own attestation method.\r\n *\r\n * @packageDocumentation\r\n */\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\nfunction registerAppCheck() {\n  // The public interface\n  _registerComponent(new Component(APP_CHECK_NAME, container => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const heartbeatServiceProvider = container.getProvider('heartbeat');\n    return factory(app, heartbeatServiceProvider);\n  }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n  /**\r\n   * Initialize app-check-internal after app-check is initialized to make AppCheck available to\r\n   * other Firebase SDKs\r\n   */.setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n  }));\n  // The internal interface used by other Firebase products\n  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n    const appCheck = container.getProvider('app-check').getImmediate();\n    return internalFactory(appCheck);\n  }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n  registerVersion(name, version);\n}\nregisterAppCheck();\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };\n","import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵAPP_CHECK_PROVIDER_NAME as _APP_CHECK_PROVIDER_NAME, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, ɵAppCheckInstances as _AppCheckInstances, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nexport { ɵAppCheckInstances as AppCheckInstances } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Optional, PLATFORM_ID, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { registerVersion } from 'firebase/app';\nimport { getLimitedUseToken as getLimitedUseToken$1, getToken as getToken$1, initializeAppCheck as initializeAppCheck$1, onTokenChanged as onTokenChanged$1, setTokenAutoRefreshEnabled as setTokenAutoRefreshEnabled$1 } from 'firebase/app-check';\nexport * from 'firebase/app-check';\nclass AppCheck {\n  constructor(appCheck) {\n    return appCheck;\n  }\n}\nconst appCheckInstance$ = /*#__PURE__*/ /*#__PURE__*/timer(0, 300).pipe( /*#__PURE__*/concatMap(() => from(_getAllInstancesOf(_APP_CHECK_PROVIDER_NAME))), /*#__PURE__*/distinct());\nconst PROVIDED_APP_CHECK_INSTANCES = /*#__PURE__*/new InjectionToken('angularfire2.app-check-instances');\nfunction defaultAppCheckInstanceFactory(provided, defaultApp) {\n  const defaultAppCheck = _getDefaultInstanceOf(_APP_CHECK_PROVIDER_NAME, provided, defaultApp);\n  return defaultAppCheck && new AppCheck(defaultAppCheck);\n}\nconst LOCALHOSTS = ['localhost', '0.0.0.0', '127.0.0.1'];\nconst isLocalhost = typeof window !== 'undefined' && /*#__PURE__*/LOCALHOSTS.includes(window.location.hostname);\nfunction appCheckInstanceFactory(fn) {\n  return (zone, injector, platformId) => {\n    // Node should use admin token provider, browser devmode and localhost should use debug token\n    if (!isPlatformServer(platformId) && (isDevMode() || isLocalhost)) {\n      globalThis.FIREBASE_APPCHECK_DEBUG_TOKEN ??= true;\n    }\n    const appCheck = zone.runOutsideAngular(() => fn(injector));\n    return new AppCheck(appCheck);\n  };\n}\nconst APP_CHECK_INSTANCES_PROVIDER = {\n  provide: _AppCheckInstances,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_APP_CHECK_INSTANCES]]\n};\nconst DEFAULT_APP_CHECK_INSTANCE_PROVIDER = {\n  provide: AppCheck,\n  useFactory: defaultAppCheckInstanceFactory,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_APP_CHECK_INSTANCES], FirebaseApp, PLATFORM_ID]\n};\nlet AppCheckModule = /*#__PURE__*/(() => {\n  class AppCheckModule {\n    constructor() {\n      registerVersion('angularfire', VERSION.full, 'app-check');\n    }\n    static ɵfac = function AppCheckModule_Factory(t) {\n      return new (t || AppCheckModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AppCheckModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [DEFAULT_APP_CHECK_INSTANCE_PROVIDER, APP_CHECK_INSTANCES_PROVIDER]\n    });\n  }\n  return AppCheckModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideAppCheck(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'app-check');\n  return makeEnvironmentProviders([DEFAULT_APP_CHECK_INSTANCE_PROVIDER, APP_CHECK_INSTANCES_PROVIDER, {\n    provide: PROVIDED_APP_CHECK_INSTANCES,\n    useFactory: appCheckInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, Injector, PLATFORM_ID, _AngularFireSchedulers, FirebaseApps, ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst getLimitedUseToken = /*#__PURE__*/_zoneWrap(getLimitedUseToken$1, true);\nconst getToken = /*#__PURE__*/_zoneWrap(getToken$1, true);\nconst initializeAppCheck = /*#__PURE__*/_zoneWrap(initializeAppCheck$1, true);\nconst onTokenChanged = /*#__PURE__*/_zoneWrap(onTokenChanged$1, true);\nconst setTokenAutoRefreshEnabled = /*#__PURE__*/_zoneWrap(setTokenAutoRefreshEnabled$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AppCheck, AppCheckModule, appCheckInstance$, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, provideAppCheck, setTokenAutoRefreshEnabled };\n","import 'firebase/compat/auth';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵcacheInstance as _cacheInstance, ɵfirebaseAppFactory as _firebaseAppFactory, ɵlazySDKProxy as _lazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins as _applyMixins } from '@angular/fire/compat';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport firebase from 'firebase/compat/app';\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\nconst proxyPolyfillCompat = {\n  name: null,\n  config: null,\n  emulatorConfig: null,\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\nconst TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\nconst LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\nconst USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\nconst PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\nconst ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => _cacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {\n  const auth = zone.runOutsideAngular(() => app.auth());\n  if (useEmulator) {\n    auth.useEmulator(...useEmulator);\n  }\n  if (tenantId) {\n    auth.tenantId = tenantId;\n  }\n  auth.languageCode = languageCode;\n  if (useDeviceLanguage) {\n    auth.useDeviceLanguage();\n  }\n  if (settings) {\n    for (const [k, v] of Object.entries(settings)) {\n      auth.settings[k] = v;\n    }\n  }\n  if (persistence) {\n    auth.setPersistence(persistence);\n  }\n  return auth;\n}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  class AngularFireAuth {\n    /**\n     * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n     */\n    authState;\n    /**\n     * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n     */\n    idToken;\n    /**\n     * Observable of the currently signed-in user (or null).\n     */\n    user;\n    /**\n     * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n     * helper properties for getting different data associated with the token as well as all the decoded payload claims\n     * (or null).\n     */\n    idTokenResult;\n    /**\n     * Observable of the currently signed-in user's credential, or null\n     */\n    credential;\n    constructor(options, name,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, useEmulator,\n    // can't use the tuple here\n    settings,\n    // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      const logins = new Subject();\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => _firebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n        auth.pipe(first()).subscribe();\n        const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({\n          bufferSize: 1,\n          refCount: false\n        }));\n        const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));\n        this.credential = merge(redirectResult, logins,\n        // pipe in null authState to make credential zipable, just a weird devexp if\n        // authState and user go null to still have a credential\n        this.authState.pipe(filter(it => !it))).pipe(\n        // handle the { user: { } } when a user is already logged in, rather have null\n        // TODO handle the type corcersion better\n        map(credential => credential?.user ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      }\n      return _lazySDKProxy(this, auth, zone, {\n        spy: {\n          apply: (name, _, val) => {\n            // If they call a signIn or createUser function listen into the promise\n            // this will give us the user credential, push onto the logins Subject\n            // to be consumed in .credential\n            if (name.startsWith('signIn') || name.startsWith('createUser')) {\n              // TODO fix the types, the trouble is UserCredential has everything optional\n              val.then(user => logins.next(user));\n            }\n          }\n        }\n      });\n    }\n    static ɵfac = function AngularFireAuth_Factory(t) {\n      return new (t || AngularFireAuth)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AngularFireAuth,\n      factory: AngularFireAuth.ɵfac,\n      providedIn: 'any'\n    });\n  }\n  return AngularFireAuth;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*#__PURE__*/_applyMixins(AngularFireAuth, [proxyPolyfillCompat]);\nlet AngularFireAuthModule = /*#__PURE__*/(() => {\n  class AngularFireAuthModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n    }\n    static ɵfac = function AngularFireAuthModule_Factory(t) {\n      return new (t || AngularFireAuthModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AngularFireAuthModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [AngularFireAuth]\n    });\n  }\n  return AngularFireAuthModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory };\n"],"mappings":"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","names":["name","version","registerVersion","VERSION","Version","ɵgetAllInstancesOf","identifier","app","apps","getApps","instances","instance","ɵAppCheckInstances","ɵAPP_CHECK_PROVIDER_NAME","noop","ɵZoneScheduler","zone","delegate","queueScheduler","work","delay","state","targetZone","workInZone","BlockUntilFirstOperator","subscriber","source","unscheduleTask","tap","ɵAngularFireSchedulers","ngZone","asyncScheduler","t","ɵɵinject","NgZone","ɵɵdefineInjectable","getSchedulers","schedulers","observeOutsideAngular","obs$","observeOn","getSchedulers","keepUnstableUntilFirst","obs$","ɵkeepUnstableUntilFirstFactory","getSchedulers","schedulers","BlockUntilFirstOperator","subscribeOn","observeOn","name","version","firebase","noopFunctions","ɵlazySDKProxy","klass","observable","zone","options","_","name","promise","mod","ret","res","self","args","it","FirebaseApp","app","FIREBASE_OPTIONS","InjectionToken","FIREBASE_APP_NAME","ɵfirebaseAppFactory","options","zone","nameOrConfig","name","config","firebase","hmr","log$1","level","args","isDevMode","FIREBASE_APP_PROVIDER","NgZone","Optional","AngularFireModule","platformId","VERSION","t","ɵɵinject","PLATFORM_ID","ɵɵdefineNgModule","ɵɵdefineInjector","ɵcacheInstance","cacheKey","moduleName","appName","fn","deps","instance","cachedDeps","it","matchDep","log","IS_HMR","newInstance","a","b","APP_CHECK_STATES","DEFAULT_STATE","DEBUG_STATE","getStateReference","app","getDebugState","DEBUG_STATE","BASE_ENDPOINT","EXCHANGE_DEBUG_TOKEN_METHOD","TOKEN_REFRESH_TIME","ONE_DAY","Refresher","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","hasSucceeded","__async","Deferred","_e","sleep","error","currentErrorWaitInterval","ms","resolve","ERRORS","ERROR_FACTORY","ErrorFactory","ensureActivated","app","getStateReference","ERROR_FACTORY","exchangeToken","_0","_1","__async","url","body","heartbeatServiceProvider","headers","heartbeatService","heartbeatsHeader","options","response","originalError","ERROR_FACTORY","responseBody","match","timeToLiveAsNumber","now","getExchangeDebugTokenRequest","app","debugToken","projectId","appId","apiKey","BASE_ENDPOINT","EXCHANGE_DEBUG_TOKEN_METHOD","DB_NAME","DB_VERSION","STORE_NAME","dbPromise","getDBPromise","resolve","reject","request","DB_NAME","DB_VERSION","event","_a","ERROR_FACTORY","db","STORE_NAME","e","writeTokenToIndexedDB","app","token","write","computeKey","write","key","value","__async","transaction","getDBPromise","STORE_NAME","request","resolve","reject","_event","event","_a","ERROR_FACTORY","computeKey","app","logger","Logger","writeTokenToStorage","app","token","isIndexedDBAvailable","writeTokenToIndexedDB","e","logger","isDebugMode","getDebugState","getDebugToken","__async","state","defaultTokenErrorData","formatDummyToken","tokenErrorData","base64","getToken$2","appCheck","forceRefresh","__async","app","ensureActivated","state","getStateReference","token","error","isValid","cachedToken","writeTokenToStorage","shouldCallListeners","isDebugMode","exchangeToken","getExchangeDebugTokenRequest","getDebugToken","tokenFromDebugExchange","e","logger","interopTokenResult","makeDummyTokenResult","notifyTokenListeners","getLimitedUseToken$1","provider","debugToken","addTokenListener","type","listener","onError","tokenObserver","validToken","initTokenRefresher","removeTokenListener","newObservers","refresher","createTokenRefresher","Refresher","result","nextRefreshTimeMillis","latestAllowableRefresh","TOKEN_REFRESH_TIME","observers","observer","AppCheckService","heartbeatServiceProvider","tokenObservers","factory","internalFactory","name","version","APP_CHECK_NAME","APP_CHECK_NAME_INTERNAL","registerAppCheck","_registerComponent","Component","container","app","heartbeatServiceProvider","factory","_identifier","_appcheckService","appCheck","internalFactory","registerVersion","name","version","LOCALHOSTS","isLocalhost","USE_EMULATOR","InjectionToken","SETTINGS","TENANT_ID","LANGUAGE_CODE","USE_DEVICE_LANGUAGE","PERSISTENCE","ɵauthFactory","app","zone","useEmulator","tenantId","languageCode","useDeviceLanguage","settings","persistence","ɵcacheInstance","auth","k","v","AngularFireAuth","options","name","platformId","schedulers","_appCheckInstances","logins","Subject","of","observeOn","switchMap","map","ɵfirebaseAppFactory","shareReplay","isPlatformServer","first","redirectResult","it","keepUnstableUntilFirst","authStateChanged","Observable","sub","next","err","idTokenChanged","switchMapTo","subscribeOn","user","from","merge","filter","credential","ɵlazySDKProxy","_","val","t","ɵɵinject","FIREBASE_OPTIONS","FIREBASE_APP_NAME","PLATFORM_ID","NgZone","ɵAngularFireSchedulers","ɵAppCheckInstances","ɵɵdefineInjectable"],"x_google_ignoreList":[0,1,2,3,4,5,6]}